### 一：浏览器的主要构成

1. 用户界面 － 包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分。
2. 浏览器引擎 － 用来查询及操作渲染引擎的接口。
3. 渲染引擎 － 用来显示请求的内容，例如，如果请求内容为 html，它负责解析 html 及 css，并将解析后的结果显示出来。
4. 网络 － 用来完成网络调用，例如 http 请求，它具有平台无关的接口，可以在不同平台上工作。
5. UI 后端 － 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。
6. JS 解释器 － 用来解释执行 JS 代码。
7. 数据存储 － 属于持久层，浏览器需要在硬盘中保存类似 cookie 的各种数据，HTML5 定义了 web database 技术，这是一种轻量级完整的客户端存储技术

需要注意的是，不同于大部分浏览器，Chrome 为每个 Tab 分配了各自的渲染引擎实例，每个 Tab 就是一个独立的进程。

### 二：渲染引擎

1. 渲染引擎最主要的用途——显示应用了 CSS 之后的 html 及图片
2. 渲染引擎首先通过网络获得所请求文档的内容，通常以 8K 分块的方式完成。下面是渲染引擎在取得内容之后的基本流程：

解析 html 以构建 dom 树 -> 构建 render 树 -> 布局 render 树 -> 绘制 render 树

渲染引擎开始解析 html，并将标签转化为内容树中的 dom 节点。接着，它解析外部 CSS 文件及 style 标签中的样式信息。这些样式信息以及 html 中的可见性指令将被用来构建另一棵树——render 树。

Render 树由一些包含有颜色和大小等属性的矩形组成，它们将被按照正确的顺序显示到屏幕上。

Render 树构建好了之后，将会执行布局过程，它将确定每个节点在屏幕上的确切坐标。再下一步就是绘制，即遍历 render 树，并使用 UI 后端层绘制每个节点。

值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。

### 三：解析与 DOM 树构建

1.  解析一个文档即将其转换为具有一定意义的结构——编码可以理解和使用的东西。解析的结果通常是表达文档结构的节点树，称为解析树或语法树。
2.  解析基于文档依据的语法规则——文档的语言或格式。每种可被解析的格式必须具有由词汇及语法规则组成的特定的文法，称为上下文无关文法。人类语言不具有这一特性，因此不能被一般的解析技术所解析。
3.  解析可以分为两个子过程——语法分析及词法分析

词法分析就是将输入分解为符号，符号是语言的词汇表——基本有效单元的集合。对于人类语言来说，它相当于我们字典中出现的所有单词。

语法分析指对语言应用语法规则。

解析器一般将工作分配给两个组件——词法分析器（有时也叫分词器）负责将输入分解为合法的符号，解析器则根据语言的语法规则分析文档结构，从而构建解析树，词法分析器知道怎么跳过空白和换行之类的无关字符。

解析过程是迭代的，解析器从词法分析器处取到一个新的符号，并试着用这个符号匹配一条语法规则，如果匹配了一条规则，这个符号对应的节点将被添加到解析树上，然后解析器请求另一个符号。如果没有匹配到规则，解析器将在内部保存该符号，并从词法分析器取下一个符号，直到所有内部保存的符号能够匹配一项语法规则。如果最终没有找到匹配的规则，解析器将抛出一个异常，这意味着文档无效或是包含语法错误。

4. DOM

输出的树，也就是解析树，是由 DOM 元素及属性节点组成的。

树的根是“document”对象。

5. 解析算法

hmtl 不能被一般的自顶向下或自底向上的解析器所解析。

原因是：

- 这门语言本身的宽容特性

- 浏览器对一些常见的非法 html 有容错机制

- 解析过程是往复的，通常源码不会在解析过程中发生改变，但在 html 中，脚本标签包含的“document.write”可能添加标签，这说明在解析过程中实际上修改了输入。

不能使用正则解析技术，浏览器为 html 定制了专属的解析器。

Html5 规范中描述了这个解析算法，算法包括两个阶段——符号化及构建树。

符号化是词法分析的过程，将输入解析为符号，html 的符号包括开始标签、结束标签、属性名及属性值。

符号识别器识别出符号后，将其传递给树构建器，并读取下一个字符，以识别下一个符号，这样直到处理完所有输入。

6. 树的解析算法

在树的构建阶段，将修改以 Document 为根的 DOM 树，将元素附加到树上。每个由符号识别器识别生成的节点将会被树构造器进行处理，规范中定义了每个符号相对应的 Dom 元素，对应的 Dom 元素将会被创建。这些元素除了会被添加到 Dom 树上，还将被添加到开放元素堆栈中。这个堆栈用来纠正嵌套的未匹配和未闭合标签，这个算法也是用状态机来描述，所有的状态采用插入模式。

7. 解析结束处理

在这个阶段，浏览器将文档标记为可交互的，并开始解析处于延时模式中的脚本——这些脚本在文档解析后执行。

文档状态将被设置为完成，同时触发一个 load 事件。

### 四：css 解析

1. Css 规范定义了 css 的词法及语法文法。

每个符号都由正则表达式定义了词法文法（词汇表）

2. Webkit 使用 Flex 和 Bison 解析生成器从 CSS 语法文件中自动生成解析器。回忆一下解析器的介绍，Bison 创建一个自底向上的解析器，Firefox 使用自顶向下解析器。它们都是将每个 css 文件解析为样式表对象，每个对象包含 css 规则，css 规则对象包含选择器和声明对象，以及其他一些符合 css 语法的对象。

### 五：处理脚本及样式表的顺序

1. 脚本

web 的模式是同步的，开发者希望解析到一个 script 标签时立即解析执行脚本，并阻塞文档的解析直到脚本执行完。如果脚本是外引的，则网络必须先请求到这个资源——这个过程也是同步的，会阻塞文档的解析直到资源被请求到。开发者可以将脚本标识为 defer，以使其不阻塞文档解析，并在文档解析结束后执行。Html5 增加了标记脚本为异步的选项，以使脚本的解析执行使用另一个线程。

2. 预解析

Webkit 和 Firefox 都做了这个优化，当执行脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 Dom 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。

3. 样式表

样式表采用另一种不同的模式。理论上，既然样式表不改变 Dom 树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，脚本可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题，这看起来是个边缘情况，但确实很常见。Firefox 在存在样式表还在加载和解析时阻塞所有的脚本，而 Chrome 只在当脚本试图访问某些可能被未加载的样式表所影响的特定的样式属性时才阻塞这些脚本。

### 六：渲染树构建

1. 当 Dom 树构建完成时，浏览器开始构建另一棵树——渲染树。渲染树由元素显示序列中的可见元素组成，它是文档的可视化表示，构建这棵树是为了以正确的顺序绘制文档内容。
2. 每个渲染对象用一个和该节点的 css 盒模型相对应的矩形区域来表示，正如 css2 所描述的那样，它包含诸如宽、高和位置之类的几何信息。盒模型的类型受该节点相关的 display 样式属性的影响（参考样式计算章节）。

3. 渲染树和 Dom 树的关系

渲染对象和 Dom 元素相对应，但这种对应关系不是一对一的，不可见的 Dom 元素不会被插入渲染树，例如 head 元素。另外，display 属性为 none 的元素也不会在渲染树中出现（visibility 属性为 hidden 的元素将出现在渲染树中）。

还有一些 Dom 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。例如，select 元素有三个渲染对象——一个显示区域、一个下拉列表及一个按钮。同样，当文本因为宽度不够而折行时，新行将作为额外的渲染元素被添加。另一个多个渲染对象的例子是不规范的 html，根据 css 规范，一个行内元素只能仅包含行内元素或仅包含块状元素，在存在混合内容时，将会创建匿名的块状渲染对象包裹住行内元素。

一些渲染对象和所对应的 Dom 节点不在树上相同的位置，例如，浮动和绝对定位的元素在文本流之外，在两棵树上的位置不同，渲染树上标识出真实的结构，并用一个占位结构标识出它们原来的位置。

一些渲染对象和所对应的 Dom 节点不在树上相同的位置，例如，浮动和绝对定位的元素在文本流之外，在两棵树上的位置不同，渲染树上标识出真实的结构，并用一个占位结构标识出它们原来的位置。

4. 创建树的流程

Webkit 中，计算样式并生成渲染对象的过程称为 attachment，每个 Dom 节点有一个 attach 方法，attachment 的过程是同步的，调用新节点的 attach 方法将节点插入到 Dom 树中。

处理 html 和 body 标签将构建渲染树的根，这个根渲染对象对应被 css 规范称为 containing block 的元素——包含了其他所有块元素的顶级块元素。它的大小就是 viewport——浏览器窗口的显示区域，Firefox 称它为 viewPortFrame，webkit 称为 RenderView，这个就是文档所指向的渲染对象，树中其他的部分都将作为一个插入的 Dom 节点被创建。

5. 样式计算

创建渲染树需要计算出每个渲染对象的可视属性，这可以通过计算每个元素的样式属性得到。

样式包括各种来源的样式表，行内样式元素及 html 中的可视化属性（例如 bgcolor），可视化属性转化为 css 样式属性。

样式表来源于浏览器默认样式表，及页面作者和用户提供的样式表——有些样式是浏览器用户提供的（浏览器允许用户定义喜欢的样式，例如，在 Firefox 中，可以通过在 Firefox Profile 目录下放置样式表实现）。

计算样式的一些困难：

- 样式数据是非常大的结构，保存大量的样式属性会带来内存问题。
- 如果不进行优化，找到每个元素匹配的规则会导致性能问题，为每个元素查找匹配的规则都需要遍历整个规则表，这个过程有很大的工作量。选择符可能有复杂的结构，匹配过程如果沿着一条开始看似正确，后来却被证明是无用的路径，则必须去尝试另一条路径。

例如，下面这个复杂选择符

div div div div｛…｝

这意味着规则应用到三个 div 的后代 div 元素，选择树上一条特定的路径去检查，这可能需要遍历节点树，最后却发现它只是两个 div 的后代，并不使用该规则，然后则需要沿着另一条路径去尝试

- 应用规则涉及非常复杂的级联，它们定义了规则的层次

6. 共享样式数据

WebkKit 节点引用样式对象（渲染样式），某些情况下，这些对象可以被节点间共享，这些节点需要是兄弟或是表兄弟节点，并且：

- 这些元素必须处于相同的鼠标状态（比如不能一个处于 hover，而另一个不是）
- 不能有元素具有 id
- 标签名必须匹配
- class 属性必须匹配
- 对应的属性必须相同
- 链接状态必须匹配
- 焦点状态必须匹配
- 不能有元素被属性选择器影响
- 元素不能有行内样式属性
- 不能有生效的兄弟选择器，webcore 在任何兄弟选择器相遇时只是简单的抛出一个全局转换，并且在它们显示时使整个文档的样式共享失效，这些包括＋选择器和类似:first-child 和:last-child 这样的选择器。

7. 机构化

样式上下文按结构划分，这些结构包括类似 border 或 color 这样的特定分类的样式信息。一个结构中的所有特性不是继承的就是非继承的，对继承的特性，除非元素自身有定义，否则就从它的 parent 继承。非继承的特性（称为 reset 特性）如果没有定义，则使用默认的值。

样式上下文树缓存完整的结构（包括计算后的值），这样，如果底层节点没有为一个结构提供定义，则使用上层节点缓存的结构。

8. 使用规则树计算样式上下文

当为一个特定的元素计算样式时，首先计算出规则树中的一条路径，或是使用已经存在的一条，然后使用路径中的规则去填充新的样式上下文，从样式的底层节点开始，它具有最高优先级（通常是最特定的选择器），遍历规则树，直到填满结构。如果在那个规则节点没有定义所需的结构规则，则沿着路径向上，直到找到该结构规则。

如果最终没有找到该结构的任何规则定义，那么如果这个结构是继承型的，则找到其在内容树中的 parent 的结构，这种情况下，我们也成功的共享了结构；如果这个结构是 reset 型的，则使用默认的值。

如果特定的节点添加了值，那么需要做一些额外的计算以将其转换为实际值，然后在树上的节点缓存该值，使它的 children 可以使用。

当一个元素和它的一个兄弟元素指向同一个树节点时，完整的样式上下文可以被它们共享。

9. 对规则进行处理以简化匹配过程

样式规则有几个来源：

- 外部样式表或 style 标签内的 css 规则
- 行内样式属性
- html 可视化属性（映射为相应的样式规则）

后面两个很容易匹配到元素，因为它们所拥有的样式属性和 html 属性可以将元素作为 key 进行映射。

解析完样式表之后，规则会根据选择符添加一些 hash 映射，映射可以是根据 id、class、标签名或是任何不属于这些分类的综合映射。如果选择符为 id，规则将被添加到 id 映射，如果是 class，则被添加到 class 映射，等等。

这个处理是匹配规则更容易，不需要查看每个声明，我们能从映射中找到一个元素的相关规则，这个优化使在进行规则匹配时减少了 95+%的工作量。

10. 样式表的级联顺序

一个样式属性的声明可能在几个样式表中出现，或是在一个样式表中出现多次，因此，应用规则的顺序至关重要，这个顺序就是级联顺序。根据 css2 的规范，级联顺序为（从低到高）：

- 浏览器声明
- 用户声明
- 作者的一般声明
- 作者的 important 声明
- 用户 important 声明

浏览器声明是最不重要的，用户只有在声明被标记为 important 时才会覆盖作者的声明。具有同等级别的声明将根据 specifity 以及它们被定义时的顺序进行排序。Html 可视化属性将被转换为匹配的 css 声明，它们被视为最低优先级的作者规则。

11. Css2 规范中定义的选择符 specifity 如下：

- 如果声明来自 style 属性，而不是一个选择器的规则，则计 1，否则计 0（＝ a）
- 计算选择器中 id 属性的数量（＝ b）
- 计算选择器中 class 及伪类的数量（＝ c）
- 计算选择器中元素名及伪元素的数量（＝ d）

接 a－b－c－d 四个数量（用一个大基数的计算系统）将得到 specifity。这里使用的基数由分类中最高的基数定义。例如，如果 a 为 14，可以使用 16 进制。不同情况下，a 为 17 时，则需要使用阿拉伯数字 17 作为基数，这种情况可能在这个选择符时发生 html body div div …（选择符中有 17 个标签，一般不太可能）。

12. 规则排序

规则匹配后，需要根据级联顺序对规则进行排序，WebKit 先将小列表用冒泡排序，再将它们合并为一个大列表，WebKit 通过为规则复写“>”操作来执行排序

### 七：布局

1. 当渲染对象被创建并添加到树中，它们并没有位置和大小，计算这些值的过程称为 layout 或 reflow。

Html 使用基于流的布局模型，意味着大部分时间，可以以单一的途径进行几何计算。流中靠后的元素并不会影响前面元素的几何特性，所以布局可以在文档中从右向左、自上而下的进行。也存在一些例外，比如 html tables。

坐标系统相对于根 frame，使用 top 和 left 坐标。

布局是一个递归的过程，由根渲染对象开始，它对应 html 文档元素，布局继续递归的通过一些或所有的 frame 层级，为每个需要几何信息的渲染对象进行计算。

根渲染对象的位置是 0,0，它的大小是 viewport－浏览器窗口的可见部分。

所有的渲染对象都有一个 layout 或 reflow 方法，每个渲染对象调用需要布局的 children 的 layout 方法。

2. Dirty bit 系统

为了不因为每个小变化都全部重新布局，浏览器使用一个 dirty bit 系统，一个渲染对象发生了变化或是被添加了，就标记它及它的 children 为 dirty——需要 layout。存在两个标识——dirty 及 children are dirty，children are dirty 说明即使这个渲染对象可能没问题，但它至少有一个 child 需要 layout。

3. 全局和增量 layout

当 layout 在整棵渲染树触发时，称为全局 layout，这可能在下面这些情况下发生：

- 一个全局的样式改变影响所有的渲染对象，比如字号的改变。

- 窗口 resize。

layout 也可以是增量的，这样只有标志为 dirty 的渲染对象会重新布局（也将导致一些额外的布局）。增量 layout 会在渲染对象 dirty 时异步触发，例如，当网络接收到新的内容并添加到 Dom 树后，新的渲染对象会添加到渲染树中。

4. 异步和同步 layout

增量 layout 的过程是异步的，Firefox 为增量 layout 生成了 reflow 队列，以及一个调度执行这些批处理命令。WebKit 也有一个计时器用来执行增量 layout－遍历树，为 dirty 状态的渲染对象重新布局。

另外，当脚本请求样式信息时，例如“offsetHeight”，会同步的触发增量布局。

全局的 layout 一般都是同步触发。

有些时候，layout 会被作为一个初始 layout 之后的回调，比如滑动条的滑动。

5. 优化

当一个 layout 因为 resize 或是渲染位置改变（并不是大小改变）而触发时，渲染对象的大小将会从缓存中读取，而不会重新计算。

一般情况下，如果只有子树发生改变，则 layout 并不从根开始。这种情况发生在，变化发生在元素自身并且不影响它周围元素，例如，将文本插入文本域（否则，每次击键都将触发从根开始的重排）。

6. ayout 一般有下面这几个部分：

1. parent 渲染对象决定它的宽度

1. parent 渲染对象读取 chilidren，并：

a. 放置 child 渲染对象（设置它的 x 和 y）

b. 在需要时（它们当前为 dirty 或是处于全局 layout 或者其他原因）调用 child 渲染对象的 layout，这将计算 child 的高度

c. parent 渲染对象使用 child 渲染对象的累积高度，以及 margin 和 padding 的高度来设置自己的高度－这将被 parent 渲染对象的 parent 使用

d. 将 dirty 标识设置为 false

Firefox 使用一个“state”对象（nsHTMLReflowState）做为参数去布局（firefox 称为 reflow），state 包含 parent 的宽度及其他内容。

Firefox 布局的输出是一个“metrics”对象（nsHTMLReflowMetrics）。它包括渲染对象计算出的高度。

7. 宽度计算

渲染对象的宽度使用容器的宽度、渲染对象样式中的宽度及 margin、border 进行计算。例如，下面这个 div 的宽度：

div

webkit 中宽度的计算过程是（RenderBox 类的 calcWidth 方法）：

容器的宽度是容器的可用宽度和 0 中的最大值，这里的可用宽度为：contentWidth=clientWidth()-paddingLeft()-paddingRight()，clientWidth 和 clientHeight 代表一个对象内部的不包括 border 和滑动条的大小
元素的宽度指样式属性 width 的值，它可以通过计算容器的百分比得到一个绝对值
加上水平方向上的 border 和 padding
　　到这里是最佳宽度的计算过程，现在计算宽度的最大值和最小值，如果最佳宽度大于最大宽度则使用最大宽度，如果小于最小宽度则使用最小宽度。最后缓存这个值，当需要 layout 但宽度未改变时使用。

8. Line breaking

当一个渲染对象在布局过程中需要折行时，则暂停并告诉它的 parent 它需要折行，parent 将创建额外的渲染对象并调用它们的 layout。

### 八：绘制

1. 绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件，这在 UI 的章节有更多的介绍。
